number' + 3 + 3
'number33'
конкатинація 

null + 3
3
якщо ми призводимо null до числа, то він буде 0, а 0+3=3


5 && "qwerty"
'qwerty’   
&& шукає false, якщо не знаходить, то виводить останнє значення. В даному випадку 5 - це true, йде далі і виводить останнє, тобто 'qwerty’ 

+'40' + +'2' + "hillel";
'42hillel'   
унарний рператор + преобразовує 40 та 2 в цілі числа і буде 42, далі спрацьовує конкатинація 


'10' - 5 === 6;
false     
js все намагається привести до числа, тому 10-5 =5, а 5 не дорівнює 6, буде false


true + false
1      
true =1 + false = 0: 1+0=1



'4px' - 3
NaN 
бо в строкі не цифри, ми не можемо привести до цифр '4px’ і в результаті це дасть нам NaN


'4' - 3
1 
js все прирівнює до чисел, тому 4-3=1


6' + 3 ** 0;
'61' 
спочатку виконуємо 3 ** 0 =1 (3 в нульовій степені), далі конкатинація 6+1='61'



12 / '6'
2  
js все намагається привести до числа, тому 12/6 =2


'10' + (5 === 6);
'10false' 
(5 === 6) - тут буде false, бо 5 не дорівнює 6, далі конкатинація 


null == ' '
false  
порівнюючи null з чимось іншим завжди отримуємо false


3 ** (9 / 3);
27   
спочатку  (9 / 3) = 3, далі 3 в 3 степені = 27


!!'false' == !!'true'
true   
'false'  це стрінга і вона true, перший ! міняє її на false, другий ! на true. Далі 'true' це теж стрінга, і вона true, перший ! міняє її на false, другий ! на true. true == true


0 || '0' && 1
1   
спочатку виконується  '0' && 1,  '0' - це true, 1 - також true, а якщо у нас && не знайшов false, то виводить останній true, тобто 1 


(+null == false) < 1
false
+null = 0,  false = 0, 0 == 0 - true, true = 1, 1 < 1 - false


false && true || true
true      
спочатку false && true = false (бо якщо хоч 1 false, то все false), залишається false || true (якщо хоч 1, true то весь вираз true)


false && (false || true)
false     
спочатку (false || true) = true, далі false && true = false


(+null == false) < 1 ** 5
false   
+null = 0, 0 = false, false == false - буде true.  1 ** 5 = 1, 1 - це true. true < true = false




